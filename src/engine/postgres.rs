use super::{DbEngine, DbSession, RowStream};
use crate::engine::dialect::{format_qualified_table, split_table_name, SqlDialect};
use crate::engine::value::SqlValue;
use crate::util::dialects::postgres::POSTGRES_DIALECT;
use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use futures::stream;
use sqlx::postgres::{PgConnection, PgRow, PgValueRef};
use sqlx::{Connection, Row, TypeInfo, ValueRef};

pub struct PostgresEngine;

#[async_trait]
impl DbEngine for PostgresEngine {
    async fn connect(&self, url: &str) -> Result<Box<dyn DbSession>> {
        let conn = PgConnection::connect(url)
            .await
            .with_context(|| format!("Failed to connect to PostgreSQL database at {}", url))?;

        Ok(Box::new(PostgresSession {
            conn,
            in_transaction: false,
            constraints_disabled: false,
        }))
    }
}

pub struct PostgresSession {
    conn: PgConnection,
    in_transaction: bool,
    constraints_disabled: bool,
}

#[async_trait]
impl DbSession for PostgresSession {
    fn dialect(&self) -> &'static dyn SqlDialect {
        &POSTGRES_DIALECT
    }

    async fn start_consistent_snapshot(&mut self) -> Result<()> {
        sqlx::query("BEGIN ISOLATION LEVEL REPEATABLE READ")
            .execute(&mut self.conn)
            .await?;
        self.in_transaction = true;
        Ok(())
    }

    async fn list_tables(&mut self, include: &[String], exclude: &[String]) -> Result<Vec<String>> {
        let rows = sqlx::query(
            "SELECT schemaname, tablename
             FROM pg_catalog.pg_tables
             WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
             ORDER BY schemaname, tablename",
        )
        .fetch_all(&mut self.conn)
        .await?;

        let mut tables: Vec<String> = rows
            .into_iter()
            .map(|row| {
                let schema: String = row.get(0);
                let table: String = row.get(1);
                format!("{}.{}", schema, table)
            })
            .collect();

        if !include.is_empty() {
            tables.retain(|t| include.iter().any(|inc| table_matches(inc, t)));
        }

        if !exclude.is_empty() {
            tables.retain(|t| !exclude.iter().any(|exc| table_matches(exc, t)));
        }

        Ok(tables)
    }

    async fn show_create_table(&mut self, table: &str) -> Result<String> {
        let (schema, name) = parse_table_name(table)?;
        let oid: i32 = sqlx::query_scalar(
            "SELECT c.oid::int
             FROM pg_class c
             INNER JOIN pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1 AND c.relname = $2",
        )
        .bind(&schema)
        .bind(&name)
        .fetch_optional(&mut self.conn)
        .await?
        .ok_or_else(|| anyhow!("Table {} not found", table))?;

        let columns = sqlx::query(
            "SELECT
                 a.attname,
                 pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
                 a.attnotnull,
                 pg_get_expr(ad.adbin, ad.adrelid) AS column_default,
                 a.attidentity
             FROM pg_attribute a
             LEFT JOIN pg_attrdef ad
               ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
             WHERE a.attrelid = $1
               AND a.attnum > 0
               AND NOT a.attisdropped
             ORDER BY a.attnum",
        )
        .bind(oid)
        .fetch_all(&mut self.conn)
        .await?;

        let mut column_defs: Vec<String> = Vec::with_capacity(columns.len());
        for col in columns {
            let name: String = col.get("attname");
            let data_type: String = col.get("data_type");
            let not_null: bool = col.get("attnotnull");
            let default_expr: Option<String> = col.get("column_default");
            let identity = col
                .try_get::<Option<String>, _>("attidentity")
                .ok()
                .flatten();

            let mut parts = Vec::new();
            parts.push(POSTGRES_DIALECT.quote_identifier(&name));
            parts.push(data_type);

            if let Some(id) = identity {
                if id == "a" {
                    parts.push("GENERATED ALWAYS AS IDENTITY".to_string());
                } else if id == "d" {
                    parts.push("GENERATED BY DEFAULT AS IDENTITY".to_string());
                }
            }

            if let Some(default) = default_expr {
                parts.push(format!("DEFAULT {}", default));
            }

            if not_null {
                parts.push("NOT NULL".to_string());
            }

            column_defs.push(parts.join(" "));
        }

        let pk_rows = sqlx::query(
            "SELECT conname, pg_get_constraintdef(oid, true) AS constraint_def
             FROM pg_constraint
             WHERE conrelid = $1 AND contype = 'p'",
        )
        .bind(oid)
        .fetch_all(&mut self.conn)
        .await?;

        for row in pk_rows {
            let name: String = row.get("conname");
            let def: String = row.get("constraint_def");
            column_defs.push(format!(
                "CONSTRAINT {} {}",
                POSTGRES_DIALECT.quote_identifier(&name),
                def
            ));
        }

        let fk_rows = sqlx::query(
            "SELECT conname, pg_get_constraintdef(oid, true) AS constraint_def
             FROM pg_constraint
             WHERE conrelid = $1 AND contype = 'f'",
        )
        .bind(oid)
        .fetch_all(&mut self.conn)
        .await?;

        for row in fk_rows {
            let name: String = row.get("conname");
            let def: String = row.get("constraint_def");
            column_defs.push(format!(
                "CONSTRAINT {} {}",
                POSTGRES_DIALECT.quote_identifier(&name),
                def
            ));
        }

        let unique_rows = sqlx::query(
            "SELECT conname, pg_get_constraintdef(oid, true) AS constraint_def
             FROM pg_constraint
             WHERE conrelid = $1 AND contype = 'u'",
        )
        .bind(oid)
        .fetch_all(&mut self.conn)
        .await?;

        for row in unique_rows {
            let name: String = row.get("conname");
            let def: String = row.get("constraint_def");
            column_defs.push(format!(
                "CONSTRAINT {} {}",
                POSTGRES_DIALECT.quote_identifier(&name),
                def
            ));
        }

        let check_rows = sqlx::query(
            "SELECT conname, pg_get_constraintdef(oid, true) AS constraint_def
             FROM pg_constraint
             WHERE conrelid = $1 AND contype = 'c'",
        )
        .bind(oid)
        .fetch_all(&mut self.conn)
        .await?;

        for row in check_rows {
            let name: String = row.get("conname");
            let def: String = row.get("constraint_def");
            column_defs.push(format!(
                "CONSTRAINT {} {}",
                POSTGRES_DIALECT.quote_identifier(&name),
                def
            ));
        }

        let qualified = format_qualified_table(&POSTGRES_DIALECT, table);
        let create_stmt = format!(
            "CREATE TABLE IF NOT EXISTS {} (\n    {}\n);",
            qualified,
            column_defs.join(",\n    ")
        );

        // Fetch and append indexes
        let index_rows = sqlx::query(
            "SELECT indexname, indexdef
             FROM pg_indexes
             WHERE schemaname = $1 AND tablename = $2
             AND indexname NOT LIKE '%_pkey'",
        )
        .bind(&schema)
        .bind(&name)
        .fetch_all(&mut self.conn)
        .await?;

        let mut full_ddl = create_stmt;
        for row in index_rows {
            let _index_name: String = row.get(0);
            let indexdef: String = row.get(1);
            full_ddl.push('\n');
            full_ddl.push_str(&indexdef);
            full_ddl.push(';');
        }

        Ok(full_ddl)
    }

    async fn stream_rows(&mut self, table: &str) -> Result<(Vec<String>, RowStream)> {
        let (schema, name) = parse_table_name(table)?;

        let column_rows = sqlx::query(
            "SELECT column_name
             FROM information_schema.columns
             WHERE table_schema = $1 AND table_name = $2
             ORDER BY ordinal_position",
        )
        .bind(&schema)
        .bind(&name)
        .fetch_all(&mut self.conn)
        .await?;

        let columns: Vec<String> = column_rows.into_iter().map(|row| row.get(0)).collect();

        let select_sql = format!(
            "SELECT * FROM {}",
            format_qualified_table(&POSTGRES_DIALECT, table)
        );

        let rows = sqlx::query(&select_sql).fetch_all(&mut self.conn).await?;

        let value_rows: Vec<Result<Vec<SqlValue>>> =
            rows.into_iter().map(|row| convert_pg_row(row)).collect();

        let row_stream = stream::iter(value_rows);
        Ok((columns, Box::pin(row_stream)))
    }

    async fn approximate_row_count(&mut self, table: &str) -> Result<u64> {
        let (schema, name) = parse_table_name(table)?;
        let estimate: Option<f64> = sqlx::query_scalar(
            "SELECT reltuples::float8
             FROM pg_class c
             INNER JOIN pg_namespace n ON n.oid = c.relnamespace
             WHERE n.nspname = $1 AND c.relname = $2",
        )
        .bind(&schema)
        .bind(&name)
        .fetch_optional(&mut self.conn)
        .await?;

        Ok(estimate.unwrap_or(0.0).max(0.0) as u64)
    }

    async fn insert_batch(
        &mut self,
        table: &str,
        column_names: &[String],
        rows: &[Vec<SqlValue>],
    ) -> Result<()> {
        if rows.is_empty() {
            return Ok(());
        }

        let sql = POSTGRES_DIALECT.insert_values_sql(table, column_names, rows);
        sqlx::query(&sql).execute(&mut self.conn).await?;
        Ok(())
    }

    async fn disable_constraints(&mut self) -> Result<()> {
        sqlx::query("SET session_replication_role = 'replica'")
            .execute(&mut self.conn)
            .await?;
        self.constraints_disabled = true;
        Ok(())
    }

    async fn enable_constraints(&mut self) -> Result<()> {
        if self.constraints_disabled {
            sqlx::query("SET session_replication_role = 'origin'")
                .execute(&mut self.conn)
                .await?;
            self.constraints_disabled = false;
        }
        Ok(())
    }

    async fn execute(&mut self, sql: &str) -> Result<()> {
        sqlx::query(sql).execute(&mut self.conn).await?;
        Ok(())
    }

    async fn commit(&mut self) -> Result<()> {
        if self.in_transaction {
            sqlx::query("COMMIT").execute(&mut self.conn).await?;
            self.in_transaction = false;
        }
        Ok(())
    }

    async fn create_table_from_columns(
        &mut self,
        table: &str,
        column_names: &[String],
        column_types: &[SqlValue],
    ) -> Result<()> {
        let qualified = format_qualified_table(&POSTGRES_DIALECT, table);
        let mut column_defs = Vec::new();

        for (col_name, col_type) in column_names.iter().zip(column_types.iter()) {
            let col_quoted = POSTGRES_DIALECT.quote_identifier(col_name);
            let type_str = match col_type {
                SqlValue::Int(_) => "INTEGER",
                SqlValue::Float(_) => "REAL",
                SqlValue::Decimal(_) => "NUMERIC(10,2)",
                SqlValue::Bool(_) => "BOOLEAN",
                SqlValue::String(_) => "VARCHAR(255)",
                SqlValue::Date { .. } => "DATE",
                SqlValue::Time { .. } => "TIME",
                SqlValue::Timestamp { .. } => "TIMESTAMP",
                SqlValue::Bytes(_) => "BYTEA",
                SqlValue::Null => "VARCHAR(255)",
            };

            let pk = if col_name == "id" && matches!(col_type, SqlValue::Int(_)) {
                " PRIMARY KEY"
            } else {
                ""
            };

            column_defs.push(format!("{} {}{}", col_quoted, type_str, pk));
        }

        let sql = format!(
            "CREATE TABLE IF NOT EXISTS {} (\n    {}\n);",
            qualified,
            column_defs.join(",\n    ")
        );

        sqlx::query(&sql)
            .execute(&mut self.conn)
            .await
            .context("Failed to create table")?;

        Ok(())
    }
}

fn convert_pg_row(row: PgRow) -> Result<Vec<SqlValue>> {
    let mut values = Vec::with_capacity(row.len());
    for idx in 0..row.len() {
        values.push(convert_pg_value(&row, idx)?);
    }
    Ok(values)
}

fn convert_pg_value(row: &PgRow, index: usize) -> Result<SqlValue> {
    let raw: PgValueRef<'_> = row.try_get_raw(index)?;
    if raw.is_null() {
        return Ok(SqlValue::Null);
    }

    let ti = raw.type_info();
    let type_name = ti.name();
    let value = match type_name {
        "BOOL" => SqlValue::Bool(row.try_get(index)?),
        "INT2" | "INT4" | "INT8" => {
            let v: i64 = row.try_get(index)?;
            SqlValue::Int(v)
        }
        "FLOAT4" | "FLOAT8" => {
            let v: f64 = row.try_get(index)?;
            SqlValue::Float(v)
        }
        "NUMERIC" | "DECIMAL" => {
            let v: String = row.try_get(index)?;
            SqlValue::Decimal(v)
        }
        "TEXT" | "VARCHAR" | "BPCHAR" | "NAME" | "JSON" | "JSONB" => {
            let v: String = row.try_get(index)?;
            SqlValue::String(v)
        }
        "BYTEA" => {
            let v: Vec<u8> = row.try_get(index)?;
            SqlValue::Bytes(v)
        }
        "DATE" => {
            let v: chrono::NaiveDate = row.try_get(index)?;
            SqlValue::from_date(v)
        }
        "TIME" => {
            let v: chrono::NaiveTime = row.try_get(index)?;
            SqlValue::from_time(v)
        }
        "TIMESTAMP" => {
            let v: chrono::NaiveDateTime = row.try_get(index)?;
            SqlValue::from_datetime(v)
        }
        "TIMESTAMPTZ" => {
            let v: chrono::DateTime<chrono::Utc> = row.try_get(index)?;
            SqlValue::from_datetime(v.naive_utc())
        }
        _ => {
            // Fallback to text representation
            let v: String = row.try_get(index)?;
            SqlValue::String(v)
        }
    };

    Ok(value)
}

fn parse_table_name(table: &str) -> Result<(String, String)> {
    let (schema, name) = split_table_name(table);
    let schema = schema
        .map(|s| s.to_string())
        .unwrap_or_else(|| "public".to_string());
    Ok((schema, name.to_string()))
}

fn table_matches(pattern: &str, qualified: &str) -> bool {
    if pattern.contains('.') {
        pattern.eq_ignore_ascii_case(qualified)
    } else {
        let (_, table_name) = split_table_name(qualified);
        pattern.eq_ignore_ascii_case(table_name)
    }
}
